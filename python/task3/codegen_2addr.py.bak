# src/task3/codegen_2addr.py
from __future__ import annotations
from dataclasses import dataclass
from typing import Dict, List, Tuple, Optional, Any

from task3.emit_asm_2addr import AsmProgram, emit_prolog, emit_epilog

# task2'nin ürettiği modellerin isimleri sende farklı olabilir.
# Bu dosyada "duck-typing" kullanıyoruz: objelerde alan var mı diye bakacağız.

WORD = 4

@dataclass
class AddrEnv:
    # func_name -> { var_name -> addr }
    addrs: Dict[str, Dict[str, int]]
    # temp slots per function
    temps: Dict[str, Dict[str, int]]

def align4(x: int) -> int:
    return (x + 3) & ~3

def build_addr_env(func_infos: List[Any]) -> AddrEnv:
    """
    func_infos: task2'den gelen fonksiyon bilgileri listesi.
    Her func_info içinde en az:
      - name veya signature.name
      - locals veya local_vars gibi bir yapı
    """
    addrs: Dict[str, Dict[str, int]] = {}
    temps: Dict[str, Dict[str, int]] = {}

    # base address plan (çakışmasız)
    base = 0x0000
    step = 0x0100  # her fonksiyona 256 byte blok (64 değişken * 4 byte) gibi düşün

    for idx, fi in enumerate(func_infos):
        fname = get_func_name(fi)
        func_base = base + idx * step
        cur = func_base

        vmap: Dict[str, int] = {}
        for v in get_func_locals(fi):
            vmap[v] = cur
            cur += WORD

        # temp slotlar
        tbase = 0x0800 + idx * step
        temps[fname] = {
            "tmp0": tbase + 0*WORD,
            "tmp1": tbase + 1*WORD,
            "tmp2": tbase + 2*WORD,
        }

        addrs[fname] = vmap

    return AddrEnv(addrs=addrs, temps=temps)

def get_func_name(fi: Any) -> str:
    # 1) fi.name
    if hasattr(fi, "name"):
        return str(getattr(fi, "name"))
    # 2) fi.signature.name
    if hasattr(fi, "signature") and hasattr(fi.signature, "name"):
        return str(fi.signature.name)
    return "unknown"

def get_func_locals(fi: Any) -> List[str]:
    # çeşitli isim ihtimallerini deniyoruz
    for attr in ["locals", "local_vars", "localVars", "vars", "variables"]:
        if hasattr(fi, attr):
            obj = getattr(fi, attr)
            # dict olabilir
            if isinstance(obj, dict):
                return [str(k) for k in obj.keys()]
            # list olabilir
            if isinstance(obj, list):
                out = []
                for it in obj:
                    if isinstance(it, str):
                        out.append(it)
                    elif hasattr(it, "name"):
                        out.append(str(it.name))
                return out
    # hiçbiri yoksa boş
    return []

# ---------- EMIT HELPERS (two-address memory operands) ----------

def imm16(x: int) -> int:
    return x & 0xFFFF

def emit_setm(p: AsmProgram, dst: int, value: int) -> None:
    p.add(f"setm 0x{imm16(dst):04x} 0x{value & 0xFFFFFFFF:08x}")

def emit_movm(p: AsmProgram, dst: int, src: int) -> None:
    p.add(f"movm 0x{imm16(dst):04x} 0x{imm16(src):04x}")

def emit_addm(p: AsmProgram, dst: int, src: int) -> None:
    p.add(f"addm 0x{imm16(dst):04x} 0x{imm16(src):04x}")

def emit_subm(p: AsmProgram, dst: int, src: int) -> None:
    p.add(f"subm 0x{imm16(dst):04x} 0x{imm16(src):04x}")

def emit_mulm(p: AsmProgram, dst: int, src: int) -> None:
    p.add(f"mulm 0x{imm16(dst):04x} 0x{imm16(src):04x}")

def emit_outm(p: AsmProgram, src: int) -> None:
    p.add(f"outm 0x{imm16(src):04x}")

def emit_cmpm(p: AsmProgram, a: int, b: int) -> None:
    p.add(f"cmpm 0x{imm16(a):04x} 0x{imm16(b):04x}")

def emit_jmp(p: AsmProgram, label: str) -> None:
    p.add(f"jmp {label}")

def emit_jzf(p: AsmProgram, label: str) -> None:
    p.add(f"jzf {label}")

def emit_jgf(p: AsmProgram, label: str) -> None:
    p.add(f"jgf {label}")

def emit_jlf(p: AsmProgram, label: str) -> None:
    p.add(f"jlf {label}")

# ---------- MAIN CODEGEN (demo first) ----------

def generate_demo_only(output_path: str) -> None:
    """
    İlk etap: sistemin çalıştığını göstermek için
    sabit 2+4=6 demo üretiyoruz.
    Bu, task3 iskeletinin doğru çalıştığını hocaya da kanıtlar.
    """
    p = AsmProgram(lines=[])
    emit_prolog(p)

    # main: x = 2 + 4; print x
    p.label("main")
    # kullanacağımız adresler (demo):
    a = 0x0000
    b = 0x0004
    x = 0x0008

    emit_setm(p, a, 2)
    emit_setm(p, b, 4)
    emit_movm(p, x, a)
    emit_addm(p, x, b)
    emit_outm(p, x)
    p.add("ret")

    emit_epilog(p)
    p.save(output_path)
